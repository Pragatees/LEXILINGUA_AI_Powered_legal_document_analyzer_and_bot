import streamlit as st
import speech_recognition as sr
from googletrans import Translator

# Set page config
st.set_page_config(
    page_title="Multilingual Speech to Text Translator",
    layout="centered"
)

# Language mapping for speech recognition
LANGUAGE_CODES = {
    "English": "en-IN",
    "Tamil": "ta-IN",
    "Hindi": "hi-IN",
    "Telugu": "te-IN",
    "Malayalam": "ml-IN",
    "Kannada": "kn-IN"
}

# Initialize recognizer and translator
recognizer = sr.Recognizer()
translator = Translator()

# App title
st.title("üåç Multilingual Speech to English Translator")
st.markdown("Speak in any supported language and get an English translation")

# Language selection
selected_lang = st.selectbox(
    "Select your spoken language:",
    options=list(LANGUAGE_CODES.keys()),
    index=0
)

# Placeholder for displaying recognized text dynamically
recognized_text_placeholder = st.empty()
translated_text_placeholder = st.empty()

def record_audio():
    with sr.Microphone() as source:
        st.info("Listening... Speak now!")
        recognizer.adjust_for_ambient_noise(source)
        try:
            audio = recognizer.listen(source, timeout=5, phrase_time_limit=10)
            st.success("Recording complete!")
            return audio
        except sr.WaitTimeoutError:
            st.error("Listening timed out. Please try again.")
            return None

# Main function to process audio and display text
def process_audio(audio, language):
    if not audio:
        return None, None

    try:
        text = recognizer.recognize_google(audio, language=LANGUAGE_CODES[language])
        translation = translator.translate(text, src=LANGUAGE_CODES[language][:2], dest='en')
        
        # Display recognized text in real-time
        recognized_text_placeholder.subheader("**Recognized Speech:**")
        recognized_text_placeholder.info(text)
        
        translated_text_placeholder.subheader("**English Translation:**")
        translated_text_placeholder.success(translation.text)

        return text, translation.text
    except sr.UnknownValueError:
        st.error("Could not understand audio. Please try again.")
        return None, None
    except sr.RequestError as e:
        st.error(f"Could not request results; {e}")
        return None, None
    except Exception as e:
        st.error(f"Error: {e}")
        return None, None

# Buttons for recording
col1, col2 = st.columns(2)
audio = None

with col1:
    if st.button("üé§ Record Audio", use_container_width=True):
        audio = record_audio()

if audio:
    process_audio(audio, selected_lang)

# Instructions
st.markdown("---")
st.markdown("### How to use:")
st.markdown("""
1. Select your spoken language from the dropdown  
2. Click the 'Record Audio' button  
3. Speak clearly into your microphone  
4. View your original speech and English translation below  
""")

st.markdown("### Supported Languages:")
st.markdown("- English\n- Tamil\n- Hindi\n- Telugu\n- Malayalam\n- Kannada")

# Footer
st.markdown("---")
st.caption("Note: Internet connection required for speech recognition and translation")

v2 :


import streamlit as st
import speech_recognition as sr
from googletrans import Translator
import fitz  # PyMuPDF
import io
import traceback

# Try to import langdetect with fallback
try:
    from langdetect import detect, LangDetectException
    LANGDETECT_AVAILABLE = True
except ImportError:
    LANGDETECT_AVAILABLE = False
    st.warning("langdetect package not available. Language detection will be limited.")

# Set page config
st.set_page_config(
    page_title="Multilingual Speech to Text Translator",
    layout="centered"
)

# Language mapping
LANGUAGE_CODES = {
    "English": "en-IN",
    "Tamil": "ta-IN",
    "Hindi": "hi-IN",
    "Telugu": "te-IN",
    "Malayalam": "ml-IN",
    "Kannada": "kn-IN"
}

LANG_CODE_TO_NAME = {
    'en': 'English',
    'ta': 'Tamil',
    'hi': 'Hindi',
    'te': 'Telugu',
    'ml': 'Malayalam',
    'kn': 'Kannada'
}

# Initialize components
recognizer = sr.Recognizer()
translator = Translator()

# App title
st.title("üåç Multilingual Speech to English Translator")
st.markdown("Speak in any supported language or upload a PDF to get English translation")

# Create tabs
tab1, tab2 = st.tabs(["Speech Translation", "PDF Text Extraction"])

# Speech Translation Tab
with tab1:
    selected_lang = st.selectbox(
        "Select your spoken language:",
        options=list(LANGUAGE_CODES.keys()),
        index=0
    )

    recognized_text_placeholder = st.empty()
    translated_text_placeholder = st.empty()

    def record_audio():
        with sr.Microphone() as source:
            st.info("Listening... Speak now!")
            recognizer.adjust_for_ambient_noise(source)
            try:
                audio = recognizer.listen(source, timeout=5, phrase_time_limit=10)
                st.success("Recording complete!")
                return audio
            except sr.WaitTimeoutError:
                st.error("Listening timed out. Please try again.")
                return None
            except Exception as e:
                st.error(f"Microphone error: {str(e)}")
                return None

    def process_audio(audio, language):
        if not audio:
            return None, None

        try:
            text = recognizer.recognize_google(audio, language=LANGUAGE_CODES[language])
            translation = translator.translate(text, src=LANGUAGE_CODES[language][:2], dest='en')
            
            recognized_text_placeholder.subheader("Recognized Speech:")
            recognized_text_placeholder.info(text)
            
            translated_text_placeholder.subheader("English Translation:")
            translated_text_placeholder.success(translation.text)

            return text, translation.text
        except sr.UnknownValueError:
            st.error("Could not understand audio. Please try again.")
            return None, None
        except sr.RequestError as e:
            st.error(f"Speech recognition service error: {str(e)}")
            return None, None
        except Exception as e:
            st.error(f"Unexpected error: {str(e)}")
            return None, None

    if st.button("üé§ Record Audio", use_container_width=True):
        audio = record_audio()
        if audio:
            process_audio(audio, selected_lang)

# PDF Extraction Tab
with tab2:
    st.header("PDF Text Extraction")
    uploaded_file = st.file_uploader("Upload PDF", type="pdf")
    
    if uploaded_file is not None:
        try:
            # Extract text from PDF
            with fitz.open(stream=uploaded_file.read(), filetype="pdf") as doc:
                text = "\n".join([page.get_text() for page in doc])
            
            if not text.strip():
                st.warning("No text found in PDF. It might be a scanned document.")
                st.stop()
            
            st.subheader("Extracted Text:")
            st.text_area("PDF Content", text, height=200, label_visibility="collapsed")
            
            # Language detection
            if LANGDETECT_AVAILABLE:
                try:
                    lang_code = detect(text)
                    detected_lang = LANG_CODE_TO_NAME.get(lang_code, f"Unknown ({lang_code})")
                    
                    st.subheader("Detected Language:")
                    st.info(detected_lang)
                    
                    if st.checkbox("Translate to English", key="pdf_translate"):
                        try:
                            translation = translator.translate(text, src=lang_code, dest='en')
                            st.subheader("English Translation:")
                            st.text_area("Translation", translation.text, height=200, label_visibility="collapsed")
                        except Exception as e:
                            st.error(f"Translation failed: {str(e)}")
                except LangDetectException:
                    st.warning("Could not detect language (not enough text)")
                except Exception as e:
                    st.error(f"Language detection failed: {str(e)}")
            else:
                st.warning("Language detection unavailable. Please install langdetect package.")
            
        except Exception as e:
            st.error(f"Failed to process PDF: {str(e)}")
            st.text(traceback.format_exc())

# Instructions
st.sidebar.markdown("### Instructions")
st.sidebar.markdown("""
- **Speech Translation**:
  1. Select language
  2. Click record button
  3. Speak clearly
  4. View translation

- **PDF Extraction**:
  1. Upload PDF
  2. View extracted text
  3. Detect language
  4. Translate to English
""")

# Footer
st.markdown("---")
st.caption("Note: Internet connection required for translation services")


v3 without UI:::::::

import streamlit as st
import speech_recognition as sr
import fitz  # PyMuPDF
import io
import traceback
import json
import time
from groq import Groq
import re
import matplotlib.pyplot as plt
import numpy as np

# Try to import langdetect with fallback
try:
    from langdetect import detect, LangDetectException
    LANGDETECT_AVAILABLE = True
except ImportError:
    LANGDETECT_AVAILABLE = False
    st.warning("langdetect package not available. Language detection will be limited.")

# Set page config
st.set_page_config(
    page_title="Multilingual Document Analyzer",
    layout="centered"
)

# Initialize Groq Client
api_key = "YOUR_GROQ_API_KEY"  # Replace with your actual Groq API key
client = Groq(api_key=api_key)

# Language mapping and translations
LANGUAGE_CODES = {
    "English": "en-IN",
    "Tamil": "ta-IN",
    "Hindi": "hi-IN",
    "Telugu": "te-IN",
    "Malayalam": "ml-IN",
    "Kannada": "kn-IN"
}

LANG_CODE_TO_NAME = {
    'en': 'English',
    'ta': 'Tamil',
    'hi': 'Hindi',
    'te': 'Telugu',
    'ml': 'Malayalam',
    'kn': 'Kannada'
}

# Field translations for each language
FIELD_TRANSLATIONS = {
    'en': {
        'category': 'Category',
        'severity': 'Severity',
        'description': 'Description',
        'why_it_matters': 'Why it matters',
        'mitigation': 'Mitigation',
        'occurrence': 'Occurrence'
    },
    'ta': {
        'category': '‡Æµ‡Æï‡Øà',
        'severity': '‡Æ§‡ØÄ‡Æµ‡Æø‡Æ∞‡ÆÆ‡Øç',
        'description': '‡Æµ‡Æø‡Æ≥‡Æï‡Øç‡Æï‡ÆÆ‡Øç',
        'why_it_matters': '‡Æè‡Æ©‡Øç ‡ÆÆ‡ØÅ‡Æï‡Øç‡Æï‡Æø‡ÆØ‡ÆÆ‡Øç',
        'mitigation': '‡Æ§‡Æ£‡Æø‡Æ™‡Øç‡Æ™‡ØÅ',
        'occurrence': '‡Æ®‡Æø‡Æï‡Æ¥‡Øç‡Æµ‡ØÅ'
    },
    'hi': {
        'category': '‡§∂‡•ç‡§∞‡•á‡§£‡•Ä',
        'severity': '‡§ó‡§Ç‡§≠‡•Ä‡§∞‡§§‡§æ',
        'description': '‡§µ‡§ø‡§µ‡§∞‡§£',
        'why_it_matters': '‡§Æ‡§π‡§§‡•ç‡§µ ‡§ï‡•ç‡§Ø‡•ã‡§Ç',
        'mitigation': '‡§∂‡§Æ‡§®',
        'occurrence': '‡§ò‡§ü‡§®‡§æ'
    },
    'te': {
        'category': '‡∞µ‡∞∞‡±ç‡∞ó‡∞Ç',
        'severity': '‡∞§‡±Ä‡∞µ‡±ç‡∞∞‡∞§',
        'description': '‡∞µ‡∞ø‡∞µ‡∞∞‡∞£',
        'why_it_matters': '‡∞é‡∞Ç‡∞¶‡±Å‡∞ï‡±Å ‡∞Æ‡±Å‡∞ñ‡±ç‡∞Ø‡∞Ç',
        'mitigation': '‡∞§‡∞ó‡±ç‡∞ó‡∞ø‡∞Ç‡∞™‡±Å',
        'occurrence': '‡∞∏‡∞Ç‡∞≠‡∞µ‡∞ø‡∞Ç‡∞ö‡∞ø‡∞®'
    },
    'ml': {
        'category': '‡¥µ‡¥ø‡¥≠‡¥æ‡¥ó‡¥Ç',
        'severity': '‡¥§‡µÄ‡¥µ‡µç‡¥∞‡¥§',
        'description': '‡¥µ‡¥ø‡¥µ‡¥∞‡¥£‡¥Ç',
        'why_it_matters': '‡¥é‡¥®‡µç‡¥§‡µÅ‡¥ï‡µä‡¥£‡µç‡¥ü‡µç ‡¥™‡µç‡¥∞‡¥ß‡¥æ‡¥®‡¥Ç',
        'mitigation': '‡¥∂‡¥Æ‡¥®‡¥Ç',
        'occurrence': '‡¥∏‡¥Ç‡¥≠‡¥µ‡¥Ç'
    },
    'kn': {
        'category': '‡≤µ‡≤∞‡≥ç‡≤ó',
        'severity': '‡≤§‡≥Ä‡≤µ‡≥ç‡≤∞‡≤§‡≥Ü',
        'description': '‡≤µ‡≤ø‡≤µ‡≤∞‡≤£‡≥Ü',
        'why_it_matters': '‡≤è‡≤ï‡≥Ü ‡≤Æ‡≥Å‡≤ñ‡≥ç‡≤Ø',
        'mitigation': '‡≤∂‡≤Æ‡≤®',
        'occurrence': '‡≤∏‡≤Ç‡≤≠‡≤µ‡≤ø‡≤∏‡≥Å‡≤µ‡≤ø‡≤ï‡≥Ü'
    }
}

# Initialize components
recognizer = sr.Recognizer()

# Initialize all session state variables
if 'extracted_text' not in st.session_state:
    st.session_state.extracted_text = ""
if 'document_language' not in st.session_state:
    st.session_state.document_language = "en"
if 'legal_risks' not in st.session_state:
    st.session_state.legal_risks = []
if 'chat_history' not in st.session_state:
    st.session_state.chat_history = []
if 'voice_input' not in st.session_state:
    st.session_state.voice_input = ""
if 'selected_speech_lang' not in st.session_state:
    st.session_state.selected_speech_lang = "en-IN"
if 'uploaded_file' not in st.session_state:
    st.session_state.uploaded_file = None
if 'analysis_complete' not in st.session_state:
    st.session_state.analysis_complete = False

def record_audio(language_code):
    """Record audio with language-specific settings"""
    with sr.Microphone() as source:
        recognizer.adjust_for_ambient_noise(source, duration=1)
        try:
            st.info(f"Listening for {language_code}... Speak now!")
            audio = recognizer.listen(source, timeout=8, phrase_time_limit=15)
            st.success("Recording complete!")
            return audio
        except sr.WaitTimeoutError:
            st.error("Listening timed out. Please try again.")
            return None
        except Exception as e:
            st.error(f"Microphone error: {str(e)}")
            return None

def transcribe_audio(audio, language_code):
    """Transcribe audio with language-specific recognition"""
    try:
        # Google Speech Recognition with selected language
        text = recognizer.recognize_google(audio, language=language_code)
        return text
    except sr.UnknownValueError:
        st.error("Could not understand audio. Please try again.")
        return None
    except sr.RequestError as e:
        st.error(f"Could not request results from speech recognition service; {e}")
        return None
    except Exception as e:
        st.error(f"Error in speech recognition: {str(e)}")
        return None

def extract_text_from_pdf(uploaded_file):
    """Improved PDF text extraction with language support"""
    try:
        doc = fitz.open(stream=uploaded_file.read(), filetype="pdf")
        text = ""
        
        # Improved extraction with layout preservation
        for page in doc:
            text += page.get_text("text", flags=fitz.TEXT_PRESERVE_LIGATURES | fitz.TEXT_PRESERVE_WHITESPACE)
            text += "\n"  # Add newline between pages
        
        # Clean up text
        text = re.sub(r'\s+', ' ', text).strip()
        
        if not text:
            return None, "en"
            
        # Detect language
        try:
            lang = detect(text[:2000])  # Check first 2000 chars for better accuracy
            if lang not in LANGUAGE_CODES:
                lang = "en"
        except:
            lang = "en"
            
        return text, lang
        
    except Exception as e:
        st.error(f"Error extracting text: {e}")
        return None, "en"

def analyze_legal_risks(legal_text, language_code):
    """Analyze legal text using Llama through Groq API"""
    prompt = f"""
    You are an expert legal analyst.
    Analyze the following legal document and extract key legal risks.
    
    IMPORTANT LANGUAGE INSTRUCTIONS:
    - The document is in {language_code} language.
    - You MUST provide all responses in the SAME LANGUAGE as the document.
    - Do NOT translate any part of the document or your analysis to English.
    - Keep all output in the document's original language ({language_code}).
    
    Step 1: Identify Key Legal Risks
    - List all possible legal risks in the document.
    - Categorize them under sections like Contractual Risks, Compliance Risks, Liability Risks, etc.

    Step 2: Explain Each Risk
    - Provide a brief explanation of why each risk is significant.
    - Suggest potential mitigation strategies.
    - Mention the exact section in the legal text where the risk occurs.
    - Assign a severity score from 1-10 for each risk (1 being minimal risk, 10 being severe risk)

    Output Format:
    {{
        "risks": [
            {{
                "name": "[Risk Name]",
                "category": "[Risk Category]",
                "description": "[Short Description]",
                "why_it_matters": "[Explanation]",
                "mitigation": "[How to address this risk]",
                "occurrence": "[Exact text from the document where the risk occurs]",
                "severity": [Score from 1-10]
            }}
        ]
    }}

    Legal Document:
    {legal_text}

    Respond ONLY with the JSON format in {language_code} language.
    Do not include any additional text before or after the JSON.
    """

    try:
        completion = client.chat.completions.create(
            model="llama3-70b-8192",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.3,
            max_tokens=4096,
            top_p=1
        )

        response_text = completion.choices[0].message.content if completion.choices else "{}"
        
        try:
            if not response_text.strip().startswith("{"):
                start_idx = response_text.find("{")
                end_idx = response_text.rfind("}")
                if start_idx >= 0 and end_idx >= 0:
                    response_text = response_text[start_idx:end_idx+1]

            risks_data = json.loads(response_text)
            return risks_data.get("risks", [])
        except json.JSONDecodeError:
            st.error("Failed to parse API response as JSON.")
            return []

    except Exception as e:
        st.error(f"Error calling Groq API: {e}")
        return []

def chat_about_legal_document(user_query, legal_risks, extracted_text, language_code):
    """Chat with the document using Llama through Groq API"""
    risk_context = "\n".join(
        f"- {risk['name']} (Severity: {risk.get('severity', 'N/A')}/10): {risk.get('description', '')}"
        for risk in legal_risks
    ) if legal_risks else "No identified risks"
    
    prompt = f"""
    You are a legal assistant analyzing a document in {language_code}.
    Document excerpt: {extracted_text[:2000]}...
    Identified risks: {risk_context}
    
    User question: {user_query}
    
    Respond in {language_code} with:
    - Concise answer (1-3 sentences)
    - Reference to specific risks if relevant
    - Page/section numbers if available
    - Grammatically correct {language_code}
    """
    
    try:
        completion = client.chat.completions.create(
            model="llama3-70b-8192",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.7,
            max_tokens=500
        )
        return completion.choices[0].message.content
    except Exception as e:
        return f"Error generating response: {str(e)}"

# App title
st.title("üåç Multilingual Document Analyzer")
st.markdown("Analyze documents and chat with AI assistant")

# Create tabs
tab1, tab2 = st.tabs(["Document Analysis", "AI Assistant"])

# Document Analysis Tab
with tab1:
    st.header("Document Text Extraction & Analysis")
    
    # File uploader - store in session state
    uploaded_file = st.file_uploader("Upload PDF", type="pdf", key="file_uploader")
    if uploaded_file is not None:
        st.session_state.uploaded_file = uploaded_file
    
    if st.session_state.uploaded_file is not None:
        try:
            # Only extract text if we haven't already or if a new file was uploaded
            if not st.session_state.extracted_text or uploaded_file != st.session_state.uploaded_file:
                with st.spinner("Extracting text from PDF..."):
                    text, lang_code = extract_text_from_pdf(st.session_state.uploaded_file)
                    st.session_state.extracted_text = text
                    st.session_state.document_language = lang_code
                    st.session_state.analysis_complete = False
            
            if not st.session_state.extracted_text.strip():
                st.warning("No text found in PDF. It might be a scanned document or image-based PDF.")
                st.stop()
            
            st.subheader("Extracted Text:")
            st.text_area("PDF Content", st.session_state.extracted_text, height=200, label_visibility="collapsed")
            
            if LANGDETECT_AVAILABLE:
                detected_lang = LANG_CODE_TO_NAME.get(st.session_state.document_language, f"Unknown ({st.session_state.document_language})")
                st.subheader("Detected Language:")
                st.info(detected_lang)
                
                if st.button("üîç Analyze Legal Risks"):
                    with st.spinner("Analyzing document for legal risks..."):
                        risks = analyze_legal_risks(st.session_state.extracted_text, st.session_state.document_language)
                        st.session_state.legal_risks = risks
                        st.session_state.analysis_complete = True
                        st.success("Analysis complete!")
            
            if st.session_state.analysis_complete and st.session_state.legal_risks:
                st.subheader("Identified Legal Risks:")
                translations = FIELD_TRANSLATIONS.get(st.session_state.document_language, FIELD_TRANSLATIONS['en'])
                
                # Calculate risk statistics for the graph
                severity_scores = [risk.get('severity', 0) for risk in st.session_state.legal_risks]
                avg_severity = sum(severity_scores) / len(severity_scores) if severity_scores else 0
                max_severity = max(severity_scores) if severity_scores else 0
                risk_count = len(st.session_state.legal_risks)
                
                # Create severity categories
                critical_risks = sum(1 for score in severity_scores if score >= 9)
                high_risks = sum(1 for score in severity_scores if 7 <= score < 9)
                medium_risks = sum(1 for score in severity_scores if 4 <= score < 7)
                low_risks = sum(1 for score in severity_scores if score < 4)
                
                # Create the severity graph
                fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))
                
                # Bar chart for severity scores
                risks_sorted = sorted(st.session_state.legal_risks, key=lambda x: x.get('severity', 0), reverse=True)
                risk_names = [risk.get('name', f'Risk {i+1}')[:20] for i, risk in enumerate(risks_sorted)]
                severities = [risk.get('severity', 0) for risk in risks_sorted]
                
                colors = []
                for severity in severities:
                    if severity >= 9:
                        colors.append('red')
                    elif severity >= 7:
                        colors.append('orange')
                    elif severity >= 4:
                        colors.append('yellow')
                    else:
                        colors.append('green')
                
                bars = ax1.barh(risk_names, severities, color=colors)
                ax1.set_xlabel('Severity Score (1-10)')
                ax1.set_title('Risk Severity Assessment')
                ax1.set_xlim(0, 10)
                
                # Add severity value labels
                for bar in bars:
                    width = bar.get_width()
                    ax1.text(width - 0.5, bar.get_y() + bar.get_height()/2,
                            f'{width:.1f}',
                            ha='center', va='center', color='black')
                
                # Pie chart for risk distribution
                labels = ['Critical (9-10)', 'High (7-8)', 'Medium (4-6)', 'Low (1-3)']
                sizes = [critical_risks, high_risks, medium_risks, low_risks]
                colors_pie = ['red', 'orange', 'yellow', 'green']
                explode = (0.1, 0, 0, 0)  # explode critical risks
                
                ax2.pie(sizes, explode=explode, labels=labels, colors=colors_pie,
                       autopct='%1.1f%%', shadow=True, startangle=140)
                ax2.axis('equal')
                ax2.set_title('Risk Distribution by Severity')
                
                plt.tight_layout()
                
                # Display the graph
                st.pyplot(fig)
                
                # Display risk statistics
                st.markdown(f"""
                ### Overall Risk Assessment
                **Average Risk Severity:** {avg_severity:.1f}/10  
                **Highest Risk Severity:** {max_severity}/10  
                **Total Risks Identified:** {risk_count}
                """)
                
                # Display individual risks
                for i, risk in enumerate(st.session_state.legal_risks, 1):
                    with st.expander(f"{i}. {risk.get('name', 'Unnamed Risk')}"):
                        st.markdown(f"""
                        **{translations['category']}:** {risk.get('category', 'N/A')}  
                        **{translations['severity']}:** {risk.get('severity', 'N/A')}/10  
                        **{translations['description']}:** {risk.get('description', 'No description')}  
                        **{translations['why_it_matters']}:** {risk.get('why_it_matters', 'N/A')}  
                        **{translations['mitigation']}:** {risk.get('mitigation', 'No mitigation strategy')}  
                        **{translations['occurrence']}:**  
                        ```text
                        {risk.get('occurrence', 'Not specified')}
                        ```
                        """)
            
        except Exception as e:
            st.error(f"Failed to process PDF: {str(e)}")
            st.text(traceback.format_exc())

# AI Assistant Tab
with tab2:
    st.header("AI Assistant Chat")
    
    if not st.session_state.extracted_text:
        st.info("Please upload and analyze a PDF document first.")
    else:
        # Language selection for speech input
        selected_lang_name = st.selectbox(
            "Select your speaking language:",
            options=list(LANGUAGE_CODES.keys()),
            index=0,
            key="lang_selector"
        )
        st.session_state.selected_speech_lang = LANGUAGE_CODES[selected_lang_name]
        
        # Display chat history
        for message in st.session_state.chat_history:
            if message["role"] == "user":
                with st.chat_message("user"):
                    st.markdown(f"**You:** {message['content']}")
                    if message.get("voice_input"):
                        st.caption(f"Voice input ({selected_lang_name}): {message['voice_input']}")
            else:
                with st.chat_message("assistant"):
                    st.markdown(message["content"])
        
        # Voice input section
        col1, col2 = st.columns([3, 1])
        with col1:
            if st.button("üé§ Record Voice Input", use_container_width=True, key="record_voice"):
                with st.spinner(f"Listening for {selected_lang_name}..."):
                    audio = record_audio(st.session_state.selected_speech_lang)
                    if audio:
                        transcribed_text = transcribe_audio(audio, st.session_state.selected_speech_lang)
                        if transcribed_text:
                            st.session_state.voice_input = transcribed_text
                            st.rerun()
        
        if st.session_state.voice_input:
            st.text_input("Voice input captured:", value=st.session_state.voice_input, disabled=True, key="voice_input_display")
        
        # Text input
        user_input = st.chat_input("Type your question...", key="chat_input")
        
        if user_input or st.session_state.voice_input:
            final_input = st.session_state.voice_input if st.session_state.voice_input else user_input
            
            st.session_state.chat_history.append({
                "role": "user",
                "content": final_input,
                "voice_input": st.session_state.voice_input if st.session_state.voice_input else None
            })
            
            st.session_state.voice_input = ""
            
            with st.spinner("Thinking..."):
                response = chat_about_legal_document(
                    final_input,
                    st.session_state.legal_risks,
                    st.session_state.extracted_text,
                    st.session_state.document_language
                )
                st.session_state.chat_history.append({"role": "assistant", "content": response})
            
            st.rerun()

# Instructions
st.sidebar.markdown("### Instructions")
st.sidebar.markdown("""
- **Document Analysis**:
  1. Upload PDF
  2. View extracted text
  3. Detect language
  4. Analyze for legal risks

- **AI Assistant**:
  1. Upload and analyze PDF first
  2. Select your speaking language
  3. Ask questions via text or voice
  4. Get document-specific answers
""")

# Footer
st.markdown("---")
st.caption("Note: Internet connection required for all services")




fully working code ::::


import streamlit as st
import speech_recognition as sr
import fitz  # PyMuPDF
import io
import traceback
import json
import time
from groq import Groq
import re
import matplotlib.pyplot as plt
import numpy as np
from streamlit_extras.colored_header import colored_header
from streamlit_extras.card import card
from streamlit_extras.metric_cards import style_metric_cards
from streamlit_extras.stylable_container import stylable_container

# Set page config
st.set_page_config(
    page_title="Multilingual Document Analyzer",
    layout="centered",
    initial_sidebar_state="expanded"
)

# Initialize Groq Client
api_key = "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"  # Replace with your actual Groq API key
client = Groq(api_key=api_key)

# Language mapping and translations
LANGUAGE_CODES = {
    "English": "en-IN",
    "Tamil": "ta-IN",
    "Hindi": "hi-IN",
    "Telugu": "te-IN",
    "Malayalam": "ml-IN",
    "Kannada": "kn-IN"
}

LANGUAGE_NAMES = {
    "en": "English",
    "ta": "Tamil",
    "hi": "Hindi",
    "te": "Telugu",
    "ml": "Malayalam",
    "kn": "Kannada"
}

# Field translations for each language
FIELD_TRANSLATIONS = {
    'en': {
        'category': 'Category',
        'severity': 'Severity',
        'description': 'Description',
        'why_it_matters': 'Why it matters',
        'mitigation': 'Mitigation',
        'occurrence': 'Occurrence'
    },
    'ta': {
        'category': '‡Æµ‡Æï‡Øà',
        'severity': '‡Æ§‡ØÄ‡Æµ‡Æø‡Æ∞‡ÆÆ‡Øç',
        'description': '‡Æµ‡Æø‡Æ≥‡Æï‡Øç‡Æï‡ÆÆ‡Øç',
        'why_it_matters': '‡Æè‡Æ©‡Øç ‡ÆÆ‡ØÅ‡Æï‡Øç‡Æï‡Æø‡ÆØ‡ÆÆ‡Øç',
        'mitigation': '‡Æ§‡Æ£‡Æø‡Æ™‡Øç‡Æ™‡ØÅ',
        'occurrence': '‡Æ®‡Æø‡Æï‡Æ¥‡Øç‡Æµ‡ØÅ'
    },
    'hi': {
        'category': '‡§∂‡•ç‡§∞‡•á‡§£‡•Ä',
        'severity': '‡§ó‡§Ç‡§≠‡•Ä‡§∞‡§§‡§æ',
        'description': '‡§µ‡§ø‡§µ‡§∞‡§£',
        'why_it_matters': '‡§Æ‡§π‡§§‡•ç‡§µ ‡§ï‡•ç‡§Ø‡•ã‡§Ç',
        'mitigation': '‡§∂‡§Æ‡§®',
        'occurrence': '‡§ò‡§ü‡§®‡§æ'
    },
    'te': {
        'category': '‡∞µ‡∞∞‡±ç‡∞ó‡∞Ç',
        'severity': '‡∞§‡±Ä‡∞µ‡±ç‡∞∞‡∞§',
        'description': '‡∞µ‡∞ø‡∞µ‡∞∞‡∞£',
        'why_it_matters': '‡∞é‡∞Ç‡∞¶‡±Å‡∞ï‡±Å ‡∞Æ‡±Å‡∞ñ‡±ç‡∞Ø‡∞Ç',
        'mitigation': '‡∞§‡∞ó‡±ç‡∞ó‡∞ø‡∞Ç‡∞™‡±Å',
        'occurrence': '‡∞∏‡∞Ç‡∞≠‡∞µ‡∞ø‡∞Ç‡∞ö‡∞ø‡∞®'
    },
    'ml': {
        'category': '‡¥µ‡¥ø‡¥≠‡¥æ‡¥ó‡¥Ç',
        'severity': '‡¥§‡µÄ‡¥µ‡µç‡¥∞‡¥§',
        'description': '‡¥µ‡¥ø‡¥µ‡¥∞‡¥£‡¥Ç',
        'why_it_matters': '‡¥é‡¥®‡µç‡¥§‡µÅ‡¥ï‡µä‡¥£‡µç‡¥ü‡µç ‡¥™‡µç‡¥∞‡¥ß‡¥æ‡¥®‡¥Ç',
        'mitigation': '‡¥∂‡¥Æ‡¥®‡¥Ç',
        'occurrence': '‡¥∏‡¥Ç‡¥≠‡¥µ‡¥Ç'
    },
    'kn': {
        'category': '‡≤µ‡≤∞‡≥ç‡≤ó',
        'severity': '‡≤§‡≥Ä‡≤µ‡≥ç‡≤∞‡≤§‡≥Ü',
        'description': '‡≤µ‡≤ø‡≤µ‡≤∞‡≤£‡≥Ü',
        'why_it_matters': '‡≤è‡≤ï‡≥Ü ‡≤Æ‡≥Å‡≤ñ‡≥ç‡≤Ø',
        'mitigation': '‡≤∂‡≤Æ‡≤®',
        'occurrence': '‡≤∏‡≤Ç‡≤≠‡≤µ‡≤ø‡≤∏‡≥Å‡≤µ‡≤ø‡≤ï‡≥Ü'
    }
}

# Initialize components
recognizer = sr.Recognizer()

# Initialize all session state variables
if 'extracted_text' not in st.session_state:
    st.session_state.extracted_text = ""
if 'document_language' not in st.session_state:
    st.session_state.document_language = "en"
if 'legal_risks' not in st.session_state:
    st.session_state.legal_risks = []
if 'chat_history' not in st.session_state:
    st.session_state.chat_history = []
if 'voice_input' not in st.session_state:
    st.session_state.voice_input = ""
if 'selected_speech_lang' not in st.session_state:
    st.session_state.selected_speech_lang = "en-IN"
if 'uploaded_file' not in st.session_state:
    st.session_state.uploaded_file = None
if 'analysis_complete' not in st.session_state:
    st.session_state.analysis_complete = False

def record_audio(language_code):
    """Record audio with language-specific settings"""
    with sr.Microphone() as source:
        recognizer.adjust_for_ambient_noise(source, duration=1)
        try:
            st.info(f"Listening for {language_code}... Speak now!")
            audio = recognizer.listen(source, timeout=8, phrase_time_limit=15)
            st.success("Recording complete!")
            return audio
        except sr.WaitTimeoutError:
            st.error("Listening timed out. Please try again.")
            return None
        except Exception as e:
            st.error(f"Microphone error: {str(e)}")
            return None

def transcribe_audio(audio, language_code):
    """Transcribe audio with language-specific recognition"""
    try:
        # Google Speech Recognition with selected language
        text = recognizer.recognize_google(audio, language=language_code)
        return text
    except sr.UnknownValueError:
        st.error("Could not understand audio. Please try again.")
        return None
    except sr.RequestError as e:
        st.error(f"Could not request results from speech recognition service; {e}")
        return None
    except Exception as e:
        st.error(f"Error in speech recognition: {str(e)}")
        return None

def extract_text_from_pdf(uploaded_file):
    """Improved PDF text extraction"""
    try:
        doc = fitz.open(stream=uploaded_file.read(), filetype="pdf")
        text = ""
        
        # Improved extraction with layout preservation
        for page in doc:
            text += page.get_text("text", flags=fitz.TEXT_PRESERVE_LIGATURES | fitz.TEXT_PRESERVE_WHITESPACE)
            text += "\n"  # Add newline between pages
        
        # Clean up text
        text = re.sub(r'\s+', ' ', text).strip()
        
        if not text:
            return None
            
        return text
        
    except Exception as e:
        st.error(f"Error extracting text: {e}")
        return None

def analyze_legal_risks(legal_text, language_code):
    """Analyze legal text using Llama through Groq API"""
    prompt = f"""
    You are an expert legal analyst.
    Analyze the following legal document and extract key legal risks.
    
    IMPORTANT LANGUAGE INSTRUCTIONS:
    - The document is in {language_code} language.
    - You MUST provide all responses in the language of {language_code}.
    - Do NOT translate any part of the document or your analysis to English.
    - Keep all output in the document's original language ({language_code}).
    
    Step 1: Identify Key Legal Risks
    - List all possible legal risks in the document.
    - Categorize them under sections like Contractual Risks, Compliance Risks, Liability Risks, etc.

    Step 2: Explain Each Risk
    - Provide a brief explanation of why each risk is significant.
    - Suggest potential mitigation strategies.
    - Mention the exact section in the legal text where the risk occurs.
    - Assign a severity score from 1-10 for each risk (1 being minimal risk, 10 being severe risk)

    Output Format:
    {{
        "risks": [
            {{
                "name": "[Risk Name]",
                "category": "[Risk Category]",
                "description": "[Short Description]",
                "why_it_matters": "[Explanation]",
                "mitigation": "[How to address this risk]",
                "occurrence": "[Exact text that closely related to that risk]",
                "severity": [Score from 1-10]
            }}
        ]
    }}

    Legal Document:
    {legal_text}
    
    If you find any grammatical mistakes in the given document , you must solve the entire mistakes and give me the output in correct grammatical manner

    Respond ONLY with the JSON format in {language_code} language.
    Do not include any additional text before or after the JSON.
    """

    try:
        completion = client.chat.completions.create(
            model="llama3-70b-8192",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.3,
            max_tokens=4096,
            top_p=1
        )

        response_text = completion.choices[0].message.content if completion.choices else "{}"
        
        try:
            if not response_text.strip().startswith("{"):
                start_idx = response_text.find("{")
                end_idx = response_text.rfind("}")
                if start_idx >= 0 and end_idx >= 0:
                    response_text = response_text[start_idx:end_idx+1]

            risks_data = json.loads(response_text)
            return risks_data.get("risks", [])
        except json.JSONDecodeError:
            st.error("Failed to parse API response as JSON.")
            return []

    except Exception as e:
        st.error(f"Error calling Groq API: {e}")
        return []

def chat_about_legal_document(user_query, legal_risks, extracted_text, language_code):
    """Chat with the document using Llama through Groq API"""
    risk_context = "\n".join(
        f"- {risk['name']} (Severity: {risk.get('severity', 'N/A')}/10): {risk.get('description', '')}"
        for risk in legal_risks
    ) if legal_risks else "No identified risks"
    
    prompt = f"""
    You are a legal assistant analyzing a document in {language_code}.
    Document excerpt: {extracted_text[:2000]}...
    Identified risks: {risk_context}
    
    User question: {user_query}
    
    Respond in {language_code} with:
    - Concise answer (1-3 sentences)
    - Reference to specific risks if relevant
    - Page/section numbers if available
    - the content in the document is not grammicatical correct some times so you must return the correct grammatical words
    - If user given content not related to document or not related to legal ascepts just tells it non relevant do not doo anything
    - Grammatically correct {language_code}
    """
    
    try:
        completion = client.chat.completions.create(
            model="llama3-70b-8192",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.7,
            max_tokens=500
        )
        return completion.choices[0].message.content
    except Exception as e:
        return f"Error generating response: {str(e)}"

# Custom CSS for styling
st.markdown("""
<style>
    .risk-card {
        border-radius: 10px;
        padding: 15px;
        margin-bottom: 15px;
        box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2);
        transition: 0.3s;
        color: black !important;
    }
    .risk-card:hover {
        box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2);
    }
    .critical {
        border-left: 5px solid #ff4b4b;
        background-color: #fff5f5;
    }
    .high {
        border-left: 5px solid #ffa500;
        background-color: #fff9e6;
    }
    .medium {
        border-left: 5px solid #ffcc00;
        background-color: #fffdf2;
    }
    .low {
        border-left: 5px solid #4CAF50;
        background-color: #f6fff6;
    }
    .severity-badge {
        border-radius: 12px;
        padding: 3px 10px;
        font-size: 0.8em;
        font-weight: bold;
        display: inline-block;
        margin-right: 10px;
    }
    .severity-critical {
        background-color: #ff4b4b;
        color: white;
    }
    .severity-high {
        background-color: #ffa500;
        color: white;
    }
    .severity-medium {
        background-color: #ffcc00;
        color: black;
    }
    .severity-low {
        background-color: #4CAF50;
        color: white;
    }
    .risk-title {
        font-size: 1.2em;
        font-weight: bold;
        margin-bottom: 5px;
        color: black !important;
    }
    .risk-category {
        font-style: italic;
        color: black !important;
        margin-bottom: 10px;
    }
    .risk-card p, .risk-card strong {
        color: black !important;
    }
    .risk-card details summary {
        color: black !important;
    }
    .risk-card details div {
        color: black !important;
    }
    .metric-card {
        border-radius: 10px;
        padding: 15px;
        margin-bottom: 15px;
        box-shadow: 0 4px 8px 0 rgba(0,0,0,0.1);
        background-color: white;
    }
    .metric-value {
        color: black !important;
        font-size: 1.5rem;
        font-weight: bold;
    }
    .metric-label {
        color: black !important;
        font-size: 1rem;
    }
</style>
""", unsafe_allow_html=True)

# App title
st.title("üåç Multilingual Document Analyzer")
st.markdown("Analyze legal documents in multiple languages with AI-powered risk assessment")

# Create tabs
tab1, tab2 = st.tabs(["üìÑ Document Analysis", "üí¨ AI Assistant"])

# Document Analysis Tab
with tab1:
    colored_header(
        label="Document Text Extraction & Analysis",
        description="Upload your legal document for risk assessment",
        color_name="blue-70"
    )
    
    # Language selection
    st.session_state.document_language = st.radio(
        "Select document language:",
        options=["English", "Tamil", "Hindi", "Telugu", "Malayalam", "Kannada"],
        index=0,
        horizontal=True
    )
    
    # File uploader - store in session state
    uploaded_file = st.file_uploader("Upload PDF Document", type="pdf", key="file_uploader")
    if uploaded_file is not None:
        st.session_state.uploaded_file = uploaded_file
    
    if st.session_state.uploaded_file is not None:
        try:
            # Only extract text if we haven't already or if a new file was uploaded
            if not st.session_state.extracted_text or uploaded_file != st.session_state.uploaded_file:
                with st.spinner("Extracting text from PDF..."):
                    text = extract_text_from_pdf(st.session_state.uploaded_file)
                    st.session_state.extracted_text = text
                    st.session_state.analysis_complete = False
            
            if not st.session_state.extracted_text.strip():
                st.warning("No text found in PDF. It might be a scanned document or image-based PDF.")
                st.stop()
            
            with st.expander("üìù View Extracted Text"):
                st.text_area("PDF Content", st.session_state.extracted_text, height=200, label_visibility="collapsed")
            
            st.info(f"üåê Selected Language: {st.session_state.document_language}")
                
            if st.button("üîç Analyze Legal Risks", type="primary"):
                with st.spinner("Analyzing document for legal risks..."):
                    lang_code = list(LANGUAGE_CODES.keys()).index(st.session_state.document_language)
                    lang_code = list(LANGUAGE_CODES.values())[lang_code][:2]  # Get 2-letter code
                    risks = analyze_legal_risks(st.session_state.extracted_text, lang_code)
                    st.session_state.legal_risks = risks
                    st.session_state.analysis_complete = True
                    st.success("Analysis complete!")
                    st.balloons()
            
            if st.session_state.analysis_complete and st.session_state.legal_risks:
                colored_header(
                    label="üìä Risk Analysis Dashboard",
                    description="Comprehensive view of identified legal risks",
                    color_name="violet-70"
                )
                
                lang_code = list(LANGUAGE_CODES.keys()).index(st.session_state.document_language)
                lang_code = list(LANGUAGE_CODES.values())[lang_code][:2]  # Get 2-letter code
                translations = FIELD_TRANSLATIONS.get(lang_code, FIELD_TRANSLATIONS['en'])
                
                # Calculate risk statistics
                severity_scores = [risk.get('severity', 0) for risk in st.session_state.legal_risks]
                avg_severity = sum(severity_scores) / len(severity_scores) if severity_scores else 0
                max_severity = max(severity_scores) if severity_scores else 0
                risk_count = len(st.session_state.legal_risks)
                
                # Create severity categories
                critical_risks = sum(1 for score in severity_scores if score >= 9)
                high_risks = sum(1 for score in severity_scores if 7 <= score < 9)
                medium_risks = sum(1 for score in severity_scores if 4 <= score < 7)
                low_risks = sum(1 for score in severity_scores if score < 4)
                
                # Display metrics in columns with white background and black text
                col1, col2, col3, col4 = st.columns(4)
                with col1:
                    with stylable_container(
                        key="metric_total",
                        css_styles="""
                            {
                                border-radius: 10px;
                                border: 1px solid #e0e0e0;
                                padding: 15px;
                                background-color: white;
                                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                            }
                            div[data-testid="stMetricValue"] {
                                color: #333333 !important;
                                font-size: 1.8rem;
                                font-weight: bold;
                                margin-top: 5px;
                            }
                            div[data-testid="stMetricLabel"] {
                                color: #555555 !important;
                                font-size: 1.1rem;
                                font-weight: 600;
                            }
                        """
                    ):
                        st.markdown("""
                        <div style='text-align: center;'>
                            <div style='font-size: 1.1rem; color: #555555; font-weight: 600;'>üìä Total Risks</div>
                            <div style='font-size: 1.8rem; color: #333333; font-weight: bold;'>{}</div>
                        </div>
                        """.format(risk_count), unsafe_allow_html=True)

                with col2:
                    with stylable_container(
                        key="metric_avg",
                        css_styles="""
                            {
                                border-radius: 10px;
                                border: 1px solid #e0e0e0;
                                padding: 15px;
                                background-color: white;
                                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                            }
                            div[data-testid="stMetricValue"] {
                                color: #333333 !important;
                                font-size: 1.8rem;
                                font-weight: bold;
                                margin-top: 5px;
                            }
                            div[data-testid="stMetricLabel"] {
                                color: #555555 !important;
                                font-size: 1.1rem;
                                font-weight: 600;
                            }
                        """
                    ):
                        st.markdown("""
                        <div style='text-align: center;'>
                            <div style='font-size: 1.1rem; color: #555555; font-weight: 600;'>‚ö†Ô∏è Avg Severity</div>
                            <div style='font-size: 1.8rem; color: #333333; font-weight: bold;'>{:.1f}/10</div>
                        </div>
                        """.format(avg_severity), unsafe_allow_html=True)

                with col3:
                    with stylable_container(
                        key="metric_max",
                        css_styles="""
                            {
                                border-radius: 10px;
                                border: 1px solid #e0e0e0;
                                padding: 15px;
                                background-color: white;
                                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                            }
                            div[data-testid="stMetricValue"] {
                                color: #333333 !important;
                                font-size: 1.8rem;
                                font-weight: bold;
                                margin-top: 5px;
                            }
                            div[data-testid="stMetricLabel"] {
                                color: #555555 !important;
                                font-size: 1.1rem;
                                font-weight: 600;
                            }
                        """
                    ):
                        st.markdown("""
                        <div style='text-align: center;'>
                            <div style='font-size: 1.1rem; color: #555555; font-weight: 600;'>üî• Max Severity</div>
                            <div style='font-size: 1.8rem; color: #333333; font-weight: bold;'>{}/10</div>
                        </div>
                        """.format(max_severity), unsafe_allow_html=True)

                with col4:
                    with stylable_container(
                        key="metric_critical",
                        css_styles="""
                            {
                                border-radius: 10px;
                                border: 1px solid #e0e0e0;
                                padding: 15px;
                                background-color: white;
                                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                            }
                            div[data-testid="stMetricValue"] {
                                color: #333333 !important;
                                font-size: 1.8rem;
                                font-weight: bold;
                                margin-top: 5px;
                            }
                            div[data-testid="stMetricLabel"] {
                                color: #555555 !important;
                                font-size: 1.1rem;
                                font-weight: 600;
                            }
                        """
                    ):
                        st.markdown("""
                        <div style='text-align: center;'>
                            <div style='font-size: 1.1rem; color: #555555; font-weight: 600;'>üö® Critical Risks</div>
                            <div style='font-size: 1.8rem; color: #333333; font-weight: bold;'>{}</div>
                        </div>
                        """.format(critical_risks), unsafe_allow_html=True)
                
                # Create the severity graph
                fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))
                
                # Bar chart for severity scores
                risks_sorted = sorted(st.session_state.legal_risks, key=lambda x: x.get('severity', 0), reverse=True)
                risk_names = [risk.get('name', f'Risk {i+1}')[:20] for i, risk in enumerate(risks_sorted)]
                severities = [risk.get('severity', 0) for risk in risks_sorted]
                
                colors = []
                for severity in severities:
                    if severity >= 9:
                        colors.append('#ff4b4b')
                    elif severity >= 7:
                        colors.append('#ffa500')
                    elif severity >= 4:
                        colors.append('#ffcc00')
                    else:
                        colors.append('#4CAF50')
                
                bars = ax1.barh(risk_names, severities, color=colors)
                ax1.set_xlabel('Severity Score (1-10)')
                ax1.set_title('Top Risks by Severity')
                ax1.set_xlim(0, 10)
                
                # Add severity value labels
                for bar in bars:
                    width = bar.get_width()
                    ax1.text(width - 0.5, bar.get_y() + bar.get_height()/2,
                            f'{width:.1f}',
                            ha='center', va='center', color='black')
                
                # Pie chart for risk distribution
                labels = ['Critical (9-10)', 'High (7-8)', 'Medium (4-6)', 'Low (1-3)']
                sizes = [critical_risks, high_risks, medium_risks, low_risks]
                colors_pie = ['#ff4b4b', '#ffa500', '#ffcc00', '#4CAF50']
                explode = (0.1, 0, 0, 0)  # explode critical risks
                
                ax2.pie(sizes, explode=explode, labels=labels, colors=colors_pie,
                       autopct='%1.1f%%', shadow=True, startangle=140)
                ax2.axis('equal')
                ax2.set_title('Risk Distribution')
                
                plt.tight_layout()
                
                # Display the graph
                st.pyplot(fig)
                
                # Display individual risks with enhanced UI
                colored_header(
                    label="üîç Detailed Risk Breakdown",
                    description="Click on each risk to view details",
                    color_name="blue-70"
                )
                
                for i, risk in enumerate(st.session_state.legal_risks, 1):
                    severity = risk.get('severity', 0)
                    
                    # Determine severity class
                    if severity >= 9:
                        severity_class = "critical"
                        badge_class = "severity-critical"
                    elif severity >= 7:
                        severity_class = "high"
                        badge_class = "severity-high"
                    elif severity >= 4:
                        severity_class = "medium"
                        badge_class = "severity-medium"
                    else:
                        severity_class = "low"
                        badge_class = "severity-low"
                    
                    with st.expander(f"Risk {i}: {risk.get('name', 'Unnamed Risk')}"):
                        st.markdown(f"""
                        <div class="risk-card {severity_class}">
                            <div style="display: flex; align-items: center; margin-bottom: 10px;">
                                <span class="severity-badge {badge_class}">Severity: {severity}/10</span>
                                <span style="color: black;">{risk.get('category', 'N/A')}</span>
                            </div>
                            <div class="risk-title">{risk.get('name', 'Unnamed Risk')}</div>
                            <div class="risk-category">{risk.get('category', 'N/A')}</div>
                            <p><strong>{translations['description']}:</strong> {risk.get('description', 'No description')}</p>
                            <p><strong>{translations['why_it_matters']}:</strong> {risk.get('why_it_matters', 'N/A')}</p>
                            <p><strong>{translations['mitigation']}:</strong> {risk.get('mitigation', 'No mitigation strategy')}</p>
                            <details>
                                <summary><strong>{translations['occurrence']}</strong></summary>
                                <div style="background: #f5f5f5; padding: 10px; border-radius: 5px; margin-top: 5px;">
                                    {risk.get('occurrence', 'Not specified')}
                                </div>
                            </details>
                        </div>
                        """, unsafe_allow_html=True)
            
        except Exception as e:
            st.error(f"Failed to process PDF: {str(e)}")
            st.text(traceback.format_exc())

# AI Assistant Tab
with tab2:
    colored_header(
        label="üí¨ AI Legal Assistant",
        description="Chat with your document in natural language",
        color_name="violet-70"
    )
    
    if not st.session_state.extracted_text:
        st.info("Please upload and analyze a PDF document first.")
    else:
        # Language selection for speech input
        selected_lang_name = st.selectbox(
            "Select your speaking language:",
            options=list(LANGUAGE_CODES.keys()),
            index=0,
            key="lang_selector"
        )
        st.session_state.selected_speech_lang = LANGUAGE_CODES[selected_lang_name]
        
        # Display chat history
        for message in st.session_state.chat_history:
            if message["role"] == "user":
                with st.chat_message("user"):
                    st.markdown(f"**You:** {message['content']}")
                    if message.get("voice_input"):
                        st.caption(f"üé§ Voice input ({selected_lang_name}): {message['voice_input']}")
            else:
                with st.chat_message("assistant"):
                    st.markdown(message["content"])
        
        # Voice input section
        col1, col2 = st.columns([3, 1])
        with col1:
            if st.button("üé§ Record Voice Input", use_container_width=True, key="record_voice"):
                with st.spinner(f"Listening for {selected_lang_name}..."):
                    audio = record_audio(st.session_state.selected_speech_lang)
                    if audio:
                        transcribed_text = transcribe_audio(audio, st.session_state.selected_speech_lang)
                        if transcribed_text:
                            st.session_state.voice_input = transcribed_text
                            st.rerun()
        
        if st.session_state.voice_input:
            st.text_input("Voice input captured:", value=st.session_state.voice_input, disabled=True, key="voice_input_display")
        
        # Text input
        user_input = st.chat_input("Type your question about the document...", key="chat_input")
        
        if user_input or st.session_state.voice_input:
            final_input = st.session_state.voice_input if st.session_state.voice_input else user_input
            
            st.session_state.chat_history.append({
                "role": "user",
                "content": final_input,
                "voice_input": st.session_state.voice_input if st.session_state.voice_input else None
            })
            
            st.session_state.voice_input = ""
            
            with st.spinner("Analyzing your question..."):
                lang_code = list(LANGUAGE_CODES.keys()).index(st.session_state.document_language)
                lang_code = list(LANGUAGE_CODES.values())[lang_code][:2]  # Get 2-letter code
                response = chat_about_legal_document(
                    final_input,
                    st.session_state.legal_risks,
                    st.session_state.extracted_text,
                    lang_code
                )
                st.session_state.chat_history.append({"role": "assistant", "content": response})
            
            st.rerun()

# Instructions
with st.sidebar:
    colored_header(
        label="‚ÑπÔ∏è Instructions",
        description="How to use this tool",
        color_name="blue-70"
    )
    
    st.markdown("""
    ### Document Analysis
    1. **Upload** your PDF document
    2. **Select** the document language
    3. **Analyze** for legal risks
    4. **Review** the risk assessment
    
    ### AI Assistant
    1. First analyze a document
    2. **Select** your preferred language
    3. **Ask questions** via text or voice
    4. Get **document-specific answers**
    """)
    
    st.markdown("---")
    st.markdown("### üîç Sample Questions")
    st.markdown("""
    - What are the main contractual risks?
    - Explain the liability clauses
    - What's the most severe risk identified?
    - How can we mitigate compliance risks?
    """)

# Footer
st.markdown("---")
st.caption("¬© 2023 Multilingual Document Analyzer | AI-powered legal risk assessment")

# Add some space at the bottom
st.markdown("<br><br>", unsafe_allow_html=True)

Need to modified:::::



import streamlit as st
import speech_recognition as sr
import fitz  # PyMuPDF
import io
import traceback
import json
import time
from groq import Groq
import re
import matplotlib.pyplot as plt
import numpy as np
import plotly.express as px
import pandas as pd
from streamlit_extras.colored_header import colored_header
from streamlit_extras.card import card
from streamlit_extras.metric_cards import style_metric_cards
from streamlit_extras.stylable_container import stylable_container

# Set page config
st.set_page_config(
    page_title="Multilingual Document Analyzer",
    layout="centered",
    initial_sidebar_state="expanded"
)

# Initialize Groq Client
api_key = "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"  # Replace with your actual Groq API key
client = Groq(api_key=api_key)

# Language mapping and translations
LANGUAGE_CODES = {
    "English": "en-IN",
    "Tamil": "ta-IN",
    "Hindi": "hi-IN",
    "Telugu": "te-IN",
    "Malayalam": "ml-IN",
    "Kannada": "kn-IN"
}

LANGUAGE_NAMES = {
    "en": "English",
    "ta": "Tamil",
    "hi": "Hindi",
    "te": "Telugu",
    "ml": "Malayalam",
    "kn": "Kannada"
}

# Field translations for each language
FIELD_TRANSLATIONS = {
    'en': {
        'category': 'Category',
        'severity': 'Severity',
        'description': 'Description',
        'why_it_matters': 'Why it matters',
        'mitigation': 'Mitigation',
        'occurrence': 'Occurrence'
    },
    'ta': {
        'category': '‡Æµ‡Æï‡Øà',
        'severity': '‡Æ§‡ØÄ‡Æµ‡Æø‡Æ∞‡ÆÆ‡Øç',
        'description': '‡Æµ‡Æø‡Æ≥‡Æï‡Øç‡Æï‡ÆÆ‡Øç',
        'why_it_matters': '‡Æè‡Æ©‡Øç ‡ÆÆ‡ØÅ‡Æï‡Øç‡Æï‡Æø‡ÆØ‡ÆÆ‡Øç',
        'mitigation': '‡Æ§‡Æ£‡Æø‡Æ™‡Øç‡Æ™‡ØÅ',
        'occurrence': '‡Æ®‡Æø‡Æï‡Æ¥‡Øç‡Æµ‡ØÅ'
    },
    'hi': {
        'category': '‡§∂‡•ç‡§∞‡•á‡§£‡•Ä',
        'severity': '‡§ó‡§Ç‡§≠‡•Ä‡§∞‡§§‡§æ',
        'description': '‡§µ‡§ø‡§µ‡§∞‡§£',
        'why_it_matters': '‡§Æ‡§π‡§§‡•ç‡§µ ‡§ï‡•ç‡§Ø‡•ã‡§Ç',
        'mitigation': '‡§∂‡§Æ‡§®',
        'occurrence': '‡§ò‡§ü‡§®‡§æ'
    },
    'te': {
        'category': '‡∞µ‡∞∞‡±ç‡∞ó‡∞Ç',
        'severity': '‡∞§‡±Ä‡∞µ‡±ç‡∞∞‡∞§',
        'description': '‡∞µ‡∞ø‡∞µ‡∞∞‡∞£',
        'why_it_matters': '‡∞é‡∞Ç‡∞¶‡±Å‡∞ï‡±Å ‡∞Æ‡±Å‡∞ñ‡±ç‡∞Ø‡∞Ç',
        'mitigation': '‡∞§‡∞ó‡±ç‡∞ó‡∞ø‡∞Ç‡∞™‡±Å',
        'occurrence': '‡∞∏‡∞Ç‡∞≠‡∞µ‡∞ø‡∞Ç‡∞ö‡∞ø‡∞®'
    },
    'ml': {
        'category': '‡¥µ‡¥ø‡¥≠‡¥æ‡¥ó‡¥Ç',
        'severity': '‡¥§‡µÄ‡¥µ‡µç‡¥∞‡¥§',
        'description': '‡¥µ‡¥ø‡¥µ‡¥∞‡¥£‡¥Ç',
        'why_it_matters': '‡¥é‡¥®‡µç‡¥§‡µÅ‡¥ï‡µä‡¥£‡µç‡¥ü‡µç ‡¥™‡µç‡¥∞‡¥ß‡¥æ‡¥®‡¥Ç',
        'mitigation': '‡¥∂‡¥Æ‡¥®‡¥Ç',
        'occurrence': '‡¥∏‡¥Ç‡¥≠‡¥µ‡¥Ç'
    },
    'kn': {
        'category': '‡≤µ‡≤∞‡≥ç‡≤ó',
        'severity': '‡≤§‡≥Ä‡≤µ‡≥ç‡≤∞‡≤§‡≥Ü',
        'description': '‡≤µ‡≤ø‡≤µ‡≤∞‡≤£‡≥Ü',
        'why_it_matters': '‡≤è‡≤ï‡≥Ü ‡≤Æ‡≥Å‡≤ñ‡≥ç‡≤Ø',
        'mitigation': '‡≤∂‡≤Æ‡≤®',
        'occurrence': '‡≤∏‡≤Ç‡≤≠‡≤µ‡≤ø‡≤∏‡≥Å‡≤µ‡≤ø‡≤ï‡≥Ü'
    }
}

# Initialize components
recognizer = sr.Recognizer()

# Initialize all session state variables
if 'extracted_text' not in st.session_state:
    st.session_state.extracted_text = ""
if 'document_language' not in st.session_state:
    st.session_state.document_language = "en"
if 'legal_risks' not in st.session_state:
    st.session_state.legal_risks = []
if 'chat_history' not in st.session_state:
    st.session_state.chat_history = []
if 'voice_input' not in st.session_state:
    st.session_state.voice_input = ""
if 'selected_speech_lang' not in st.session_state:
    st.session_state.selected_speech_lang = "en-IN"
if 'uploaded_file' not in st.session_state:
    st.session_state.uploaded_file = None
if 'analysis_complete' not in st.session_state:
    st.session_state.analysis_complete = False

def record_audio(language_code):
    """Record audio with language-specific settings"""
    with sr.Microphone() as source:
        recognizer.adjust_for_ambient_noise(source, duration=1)
        try:
            st.info(f"Listening for {language_code}... Speak now!")
            audio = recognizer.listen(source, timeout=8, phrase_time_limit=15)
            st.success("Recording complete!")
            return audio
        except sr.WaitTimeoutError:
            st.error("Listening timed out. Please try again.")
            return None
        except Exception as e:
            st.error(f"Microphone error: {str(e)}")
            return None

def transcribe_audio(audio, language_code):
    """Transcribe audio with language-specific recognition"""
    try:
        # Google Speech Recognition with selected language
        text = recognizer.recognize_google(audio, language=language_code)
        return text
    except sr.UnknownValueError:
        st.error("Could not understand audio. Please try again.")
        return None
    except sr.RequestError as e:
        st.error(f"Could not request results from speech recognition service; {e}")
        return None
    except Exception as e:
        st.error(f"Error in speech recognition: {str(e)}")
        return None

def extract_text_from_pdf(uploaded_file):
    """Improved PDF text extraction"""
    try:
        doc = fitz.open(stream=uploaded_file.read(), filetype="pdf")
        text = ""
        
        # Improved extraction with layout preservation
        for page in doc:
            text += page.get_text("text", flags=fitz.TEXT_PRESERVE_LIGATURES | fitz.TEXT_PRESERVE_WHITESPACE)
            text += "\n"  # Add newline between pages
        
        # Clean up text
        text = re.sub(r'\s+', ' ', text).strip()
        
        if not text:
            return None
            
        return text
        
    except Exception as e:
        st.error(f"Error extracting text: {e}")
        return None

def analyze_legal_risks(legal_text, language_code):
    """Analyze legal text using Llama through Groq API"""
    prompt = f"""
    You are an expert legal analyst.
    Analyze the following legal document and extract key legal risks.
    
    IMPORTANT LANGUAGE INSTRUCTIONS:
    - The document is in {language_code} language.
    - You MUST provide all responses in the language of {language_code}.
    - Do NOT translate any part of the document or your analysis to English.
    - Keep all output in the document's original language ({language_code}).
    
    Step 1: Identify Key Legal Risks
    - List all possible legal risks in the document.
    - Categorize them under sections like Contractual Risks, Compliance Risks, Liability Risks, etc.

    Step 2: Explain Each Risk
    - Provide a brief explanation of why each risk is significant.
    - Suggest potential mitigation strategies.
    - Mention the exact section in the legal text where the risk occurs.
    - Assign a severity score from 1-10 for each risk (1 being minimal risk, 10 being severe risk)

    Output Format:
    {{
        "risks": [
            {{
                "name": "[Risk Name]",
                "category": "[Risk Category]",
                "description": "[Short Description]",
                "why_it_matters": "[Explanation]",
                "mitigation": "[How to address this risk]",
                "occurrence": "[Exact text that closely related to that risk]",
                "severity": [Score from 1-10]
            }}
        ]
    }}

    Legal Document:
    {legal_text}
    
    If you find any grammatical mistakes in the given document , you must solve the entire mistakes and give me the output in correct grammatical manner

    Respond ONLY with the JSON format in {language_code} language.
    Do not include any additional text before or after the JSON.
    """

    try:
        completion = client.chat.completions.create(
            model="llama3-70b-8192",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.3,
            max_tokens=4096,
            top_p=1
        )

        response_text = completion.choices[0].message.content if completion.choices else "{}"
        
        try:
            if not response_text.strip().startswith("{"):
                start_idx = response_text.find("{")
                end_idx = response_text.rfind("}")
                if start_idx >= 0 and end_idx >= 0:
                    response_text = response_text[start_idx:end_idx+1]

            risks_data = json.loads(response_text)
            return risks_data.get("risks", [])
        except json.JSONDecodeError:
            st.error("Failed to parse API response as JSON.")
            return []

    except Exception as e:
        st.error(f"Error calling Groq API: {e}")
        return []

def chat_about_legal_document(user_query, legal_risks, extracted_text, language_code):
    """Chat with the document using Llama through Groq API"""
    risk_context = "\n".join(
        f"- {risk['name']} (Severity: {risk.get('severity', 'N/A')}/10): {risk.get('description', '')}"
        for risk in legal_risks
    ) if legal_risks else "No identified risks"
    
    prompt = f"""
    You are a legal assistant analyzing a document in {language_code}.
    Document excerpt: {extracted_text[:2000]}...
    Identified risks: {risk_context}
    
    User question: {user_query}
    
    Respond in {language_code} with:
    - Concise answer (1-3 sentences)
    - Reference to specific risks if relevant
    - Page/section numbers if available
    - the content in the document is not grammicatical correct some times so you must return the correct grammatical words
    - If user given content not related to document or not related to legal ascepts just tells it non relevant do not doo anything
    - Grammatically correct {language_code}
    """
    
    try:
        completion = client.chat.completions.create(
            model="llama3-70b-8192",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.7,
            max_tokens=500
        )
        return completion.choices[0].message.content
    except Exception as e:
        return f"Error generating response: {str(e)}"

# Custom CSS for styling
st.markdown("""
<style>
    .risk-card {
        border-radius: 10px;
        padding: 15px;
        margin-bottom: 15px;
        box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2);
        transition: 0.3s;
        color: black !important;
    }
    .risk-card:hover {
        box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2);
    }
    .critical {
        border-left: 5px solid #ff4b4b;
        background-color: #fff5f5;
    }
    .high {
        border-left: 5px solid #ffa500;
        background-color: #fff9e6;
    }
    .medium {
        border-left: 5px solid #ffcc00;
        background-color: #fffdf2;
    }
    .low {
        border-left: 5px solid #4CAF50;
        background-color: #f6fff6;
    }
    .severity-badge {
        border-radius: 12px;
        padding: 3px 10px;
        font-size: 0.8em;
        font-weight: bold;
        display: inline-block;
        margin-right: 10px;
    }
    .severity-critical {
        background-color: #ff4b4b;
        color: white;
    }
    .severity-high {
        background-color: #ffa500;
        color: white;
    }
    .severity-medium {
        background-color: #ffcc00;
        color: black;
    }
    .severity-low {
        background-color: #4CAF50;
        color: white;
    }
    .risk-title {
        font-size: 1.2em;
        font-weight: bold;
        margin-bottom: 5px;
        color: black !important;
    }
    .risk-category {
        font-style: italic;
        color: black !important;
        margin-bottom: 10px;
    }
    .risk-card p, .risk-card strong {
        color: black !important;
    }
    .risk-card details summary {
        color: black !important;
    }
    .risk-card details div {
        color: black !important;
    }
    .metric-card {
        border-radius: 10px;
        padding: 15px;
        margin-bottom: 15px;
        box-shadow: 0 4px 8px 0 rgba(0,0,0,0.1);
        background-color: white;
    }
    .metric-value {
        color: black !important;
        font-size: 1.5rem;
        font-weight: bold;
    }
    .metric-label {
        color: black !important;
        font-size: 1rem;
    }
    .stTabs [data-baseweb="tab-list"] {
        gap: 10px;
    }
    .stTabs [data-baseweb="tab"] {
        height: 50px;
        padding: 0 20px;
        background-color: #F0F2F6;
        border-radius: 10px 10px 0 0;
        font-weight: 600;
    }
    .stTabs [aria-selected="true"] {
        background-color: #4B7BFF;
        color: white;
    }
    .risk-tab {
        padding: 20px;
        background-color: white;
        border-radius: 0 10px 10px 10px;
        box-shadow: 0 4px 8px 0 rgba(0,0,0,0.1);
    }
    .risk-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
        gap: 20px;
        margin-top: 20px;
    }
    .risk-grid-item {
        background-color: white;
        border-radius: 10px;
        padding: 15px;
        box-shadow: 0 4px 8px 0 rgba(0,0,0,0.1);
    }
    .risk-timeline {
        position: relative;
        padding-left: 30px;
        margin-top: 20px;
    }
    .risk-timeline::before {
        content: '';
        position: absolute;
        left: 10px;
        top: 0;
        bottom: 0;
        width: 2px;
        background-color: #e0e0e0;
    }
    .risk-timeline-item {
        position: relative;
        margin-bottom: 20px;
    }
    .risk-timeline-item::before {
        content: '';
        position: absolute;
        left: -30px;
        top: 5px;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background-color: #4B7BFF;
    }
    .risk-timeline-content {
        background-color: white;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .risk-timeline-date {
        font-weight: bold;
        margin-bottom: 5px;
        color: #4B7BFF;
    }
    .risk-timeline-title {
        font-weight: bold;
        margin-bottom: 5px;
    }
</style>
""", unsafe_allow_html=True)

# App title
st.title("üåç Multilingual Document Analyzer")
st.markdown("Analyze legal documents in multiple languages with AI-powered risk assessment")

# Create tabs
tab1, tab2 = st.tabs(["üìÑ Document Analysis", "üí¨ AI Assistant"])

# Document Analysis Tab
with tab1:
    colored_header(
        label="Document Text Extraction & Analysis",
        description="Upload your legal document for risk assessment",
        color_name="blue-70"
    )
    
    # Language selection
    st.session_state.document_language = st.radio(
        "Select document language:",
        options=["English", "Tamil", "Hindi", "Telugu", "Malayalam", "Kannada"],
        index=0,
        horizontal=True
    )
    
    # File uploader - store in session state
    uploaded_file = st.file_uploader("Upload PDF Document", type="pdf", key="file_uploader")
    if uploaded_file is not None:
        st.session_state.uploaded_file = uploaded_file
    
    if st.session_state.uploaded_file is not None:
        try:
            # Only extract text if we haven't already or if a new file was uploaded
            if not st.session_state.extracted_text or uploaded_file != st.session_state.uploaded_file:
                with st.spinner("Extracting text from PDF..."):
                    text = extract_text_from_pdf(st.session_state.uploaded_file)
                    st.session_state.extracted_text = text
                    st.session_state.analysis_complete = False
            
            if not st.session_state.extracted_text.strip():
                st.warning("No text found in PDF. It might be a scanned document or image-based PDF.")
                st.stop()
            
            with st.expander("üìù View Extracted Text"):
                st.text_area("PDF Content", st.session_state.extracted_text, height=200, label_visibility="collapsed")
            
            st.info(f"üåê Selected Language: {st.session_state.document_language}")
                
            if st.button("üîç Analyze Legal Risks", type="primary"):
                with st.spinner("Analyzing document for legal risks..."):
                    lang_code = list(LANGUAGE_CODES.keys()).index(st.session_state.document_language)
                    lang_code = list(LANGUAGE_CODES.values())[lang_code][:2]  # Get 2-letter code
                    risks = analyze_legal_risks(st.session_state.extracted_text, lang_code)
                    st.session_state.legal_risks = risks
                    st.session_state.analysis_complete = True
                    st.success("Analysis complete!")
                    st.balloons()
            
            if st.session_state.analysis_complete and st.session_state.legal_risks:
                colored_header(
                    label="üìä Risk Analysis Dashboard",
                    description="Comprehensive view of identified legal risks",
                    color_name="violet-70"
                )
                
                lang_code = list(LANGUAGE_CODES.keys()).index(st.session_state.document_language)
                lang_code = list(LANGUAGE_CODES.values())[lang_code][:2]  # Get 2-letter code
                translations = FIELD_TRANSLATIONS.get(lang_code, FIELD_TRANSLATIONS['en'])
                
                # Calculate risk statistics
                severity_scores = [risk.get('severity', 0) for risk in st.session_state.legal_risks]
                avg_severity = sum(severity_scores) / len(severity_scores) if severity_scores else 0
                max_severity = max(severity_scores) if severity_scores else 0
                risk_count = len(st.session_state.legal_risks)
                
                # Create severity categories
                critical_risks = sum(1 for score in severity_scores if score >= 9)
                high_risks = sum(1 for score in severity_scores if 7 <= score < 9)
                medium_risks = sum(1 for score in severity_scores if 4 <= score < 7)
                low_risks = sum(1 for score in severity_scores if score < 4)
                
                # Display metrics in columns with white background and black text
                col1, col2, col3, col4 = st.columns(4)
                with col1:
                    with stylable_container(
                        key="metric_total",
                        css_styles="""
                            {
                                border-radius: 10px;
                                border: 1px solid #e0e0e0;
                                padding: 15px;
                                background-color: white;
                                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                            }
                            div[data-testid="stMetricValue"] {
                                color: #333333 !important;
                                font-size: 1.8rem;
                                font-weight: bold;
                                margin-top: 5px;
                            }
                            div[data-testid="stMetricLabel"] {
                                color: #555555 !important;
                                font-size: 1.1rem;
                                font-weight: 600;
                            }
                        """
                    ):
                        st.markdown("""
                        <div style='text-align: center;'>
                            <div style='font-size: 1.1rem; color: #555555; font-weight: 600;'>üìä Total Risks</div>
                            <div style='font-size: 1.8rem; color: #333333; font-weight: bold;'>{}</div>
                        </div>
                        """.format(risk_count), unsafe_allow_html=True)

                with col2:
                    with stylable_container(
                        key="metric_avg",
                        css_styles="""
                            {
                                border-radius: 10px;
                                border: 1px solid #e0e0e0;
                                padding: 15px;
                                background-color: white;
                                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                            }
                            div[data-testid="stMetricValue"] {
                                color: #333333 !important;
                                font-size: 1.8rem;
                                font-weight: bold;
                                margin-top: 5px;
                            }
                            div[data-testid="stMetricLabel"] {
                                color: #555555 !important;
                                font-size: 1.1rem;
                                font-weight: 600;
                            }
                        """
                    ):
                        st.markdown("""
                        <div style='text-align: center;'>
                            <div style='font-size: 1.1rem; color: #555555; font-weight: 600;'>‚ö†Ô∏è Avg Severity</div>
                            <div style='font-size: 1.8rem; color: #333333; font-weight: bold;'>{:.1f}/10</div>
                        </div>
                        """.format(avg_severity), unsafe_allow_html=True)

                with col3:
                    with stylable_container(
                        key="metric_max",
                        css_styles="""
                            {
                                border-radius: 10px;
                                border: 1px solid #e0e0e0;
                                padding: 15px;
                                background-color: white;
                                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                            }
                            div[data-testid="stMetricValue"] {
                                color: #333333 !important;
                                font-size: 1.8rem;
                                font-weight: bold;
                                margin-top: 5px;
                            }
                            div[data-testid="stMetricLabel"] {
                                color: #555555 !important;
                                font-size: 1.1rem;
                                font-weight: 600;
                            }
                        """
                    ):
                        st.markdown("""
                        <div style='text-align: center;'>
                            <div style='font-size: 1.1rem; color: #555555; font-weight: 600;'>üî• Max Severity</div>
                            <div style='font-size: 1.8rem; color: #333333; font-weight: bold;'>{}/10</div>
                        </div>
                        """.format(max_severity), unsafe_allow_html=True)

                with col4:
                    with stylable_container(
                        key="metric_critical",
                        css_styles="""
                            {
                                border-radius: 10px;
                                border: 1px solid #e0e0e0;
                                padding: 15px;
                                background-color: white;
                                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                            }
                            div[data-testid="stMetricValue"] {
                                color: #333333 !important;
                                font-size: 1.8rem;
                                font-weight: bold;
                                margin-top: 5px;
                            }
                            div[data-testid="stMetricLabel"] {
                                color: #555555 !important;
                                font-size: 1.1rem;
                                font-weight: 600;
                            }
                        """
                    ):
                        st.markdown("""
                        <div style='text-align: center;'>
                            <div style='font-size: 1.1rem; color: #555555; font-weight: 600;'>üö® Critical Risks</div>
                            <div style='font-size: 1.8rem; color: #333333; font-weight: bold;'>{}</div>
                        </div>
                        """.format(critical_risks), unsafe_allow_html=True)
                
                # Create tabs for different views
                risk_tabs = st.tabs(["üìà Visualizations", "üìã Risk List", "üîÑ Risk Timeline", "üñáÔ∏è Risk Cards"])
                
                with risk_tabs[0]:  # Visualizations tab
                    st.subheader("Risk Severity Distribution")
                    
                    # Create a DataFrame for visualization
                    risk_df = pd.DataFrame({
                        'Risk': [risk['name'] for risk in st.session_state.legal_risks],
                        'Severity': [risk.get('severity', 0) for risk in st.session_state.legal_risks],
                        'Category': [risk.get('category', 'Uncategorized') for risk in st.session_state.legal_risks]
                    })
                    
                    # Create columns for charts
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        # Severity distribution pie chart
                        fig_pie = px.pie(
                            risk_df, 
                            names=pd.cut(
                                risk_df['Severity'], 
                                bins=[0, 4, 7, 9, 10],
                                labels=['Low (1-3)', 'Medium (4-6)', 'High (7-8)', 'Critical (9-10)']
                            ),
                            title='Risk Severity Distribution',
                            hole=0.3,
                            color_discrete_sequence=['#4CAF50', '#FFCC00', '#FFA500', '#FF4B4B']
                        )
                        fig_pie.update_traces(textposition='inside', textinfo='percent+label')
                        st.plotly_chart(fig_pie, use_container_width=True)
                    
                    with col2:
                        # Severity by category bar chart
                        fig_bar = px.bar(
                            risk_df,
                            x='Category',
                            y='Severity',
                            color='Severity',
                            color_continuous_scale=['#4CAF50', '#FFCC00', '#FFA500', '#FF4B4B'],
                            title='Average Severity by Category',
                            text='Severity'
                        )
                        fig_bar.update_layout(
                            coloraxis_showscale=False,
                            yaxis_title='Average Severity',
                            xaxis_title='Risk Category'
                        )
                        st.plotly_chart(fig_bar, use_container_width=True)
                    
                    # Severity heatmap
                    st.subheader("Risk Severity Heatmap")
                    fig_heatmap = px.density_heatmap(
                        risk_df,
                        x='Category',
                        y='Severity',
                        nbinsx=10,
                        nbinsy=10,
                        color_continuous_scale='Viridis',
                        title='Risk Concentration by Category and Severity'
                    )
                    st.plotly_chart(fig_heatmap, use_container_width=True)
                
                with risk_tabs[1]:  # Risk List tab
                    st.subheader("Detailed Risk Breakdown")
                    
                    # Create a sortable and filterable table
                    risk_data = []
                    for i, risk in enumerate(st.session_state.legal_risks, 1):
                        risk_data.append({
                            "ID": i,
                            "Risk Name": risk.get('name', 'Unnamed Risk'),
                            "Category": risk.get('category', 'Uncategorized'),
                            "Severity": risk.get('severity', 0),
                            "Description": risk.get('description', 'No description')
                        })
                    
                    risk_df = pd.DataFrame(risk_data)
                    
                    # Add severity level column for filtering
                    risk_df['Severity Level'] = pd.cut(
                        risk_df['Severity'],
                        bins=[0, 4, 7, 9, 10],
                        labels=['Low', 'Medium', 'High', 'Critical']
                    )
                    
                    # Create filters
                    col1, col2 = st.columns(2)
                    with col1:
                        severity_filter = st.multiselect(
                            "Filter by Severity Level",
                            options=['Low', 'Medium', 'High', 'Critical'],
                            default=['High', 'Critical']
                        )
                    with col2:
                        category_filter = st.multiselect(
                            "Filter by Category",
                            options=risk_df['Category'].unique(),
                            default=risk_df['Category'].unique()
                        )
                    
                    # Apply filters
                    filtered_df = risk_df[
                        (risk_df['Severity Level'].isin(severity_filter)) &
                        (risk_df['Category'].isin(category_filter))
                    ].sort_values('Severity', ascending=False)
                    
                    # Display the table
                    st.dataframe(
                        filtered_df,
                        column_config={
                            "Severity": st.column_config.ProgressColumn(
                                "Severity",
                                help="Risk severity level",
                                format="%d",
                                min_value=1,
                                max_value=10,
                            ),
                            "ID": None
                        },
                        hide_index=True,
                        use_container_width=True
                    )
                
                with risk_tabs[2]:  # Risk Timeline tab
                    st.subheader("Risk Timeline View")
                    
                    # Create a timeline view
                    st.markdown("""
                    <div class="risk-timeline">
                    """, unsafe_allow_html=True)
                    
                    for i, risk in enumerate(st.session_state.legal_risks, 1):
                        severity = risk.get('severity', 0)
                        
                        # Determine severity color
                        if severity >= 9:
                            color = "#ff4b4b"
                        elif severity >= 7:
                            color = "#ffa500"
                        elif severity >= 4:
                            color = "#ffcc00"
                        else:
                            color = "#4CAF50"
                        
                        st.markdown(f"""
                        <div class="risk-timeline-item">
                            <div class="risk-timeline-content" style="border-left: 4px solid {color};">
                                <div class="risk-timeline-title">Risk {i}: {risk.get('name', 'Unnamed Risk')}</div>
                                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                    <span><strong>{translations['category']}:</strong> {risk.get('category', 'N/A')}</span>
                                    <span style="background-color: {color}; color: white; padding: 2px 8px; border-radius: 12px; font-size: 0.8em;">
                                        Severity: {severity}/10
                                    </span>
                                </div>
                                <p><strong>{translations['description']}:</strong> {risk.get('description', 'No description')}</p>
                                <details>
                                    <summary><strong>{translations['mitigation']}</strong></summary>
                                    <div style="background: #f5f5f5; padding: 10px; border-radius: 5px; margin-top: 5px;">
                                        {risk.get('mitigation', 'No mitigation strategy')}
                                    </div>
                                </details>
                            </div>
                        </div>
                        """, unsafe_allow_html=True)
                    
                    st.markdown("</div>", unsafe_allow_html=True)
                
                with risk_tabs[3]:  # Risk Cards tab
                    st.subheader("Risk Card View")
                    
                    # Create a grid layout for cards
                    st.markdown('<div class="risk-grid">', unsafe_allow_html=True)
                    
                    for i, risk in enumerate(st.session_state.legal_risks, 1):
                        severity = risk.get('severity', 0)
                        
                        # Determine severity class
                        if severity >= 9:
                            severity_class = "critical"
                            badge_class = "severity-critical"
                        elif severity >= 7:
                            severity_class = "high"
                            badge_class = "severity-high"
                        elif severity >= 4:
                            severity_class = "medium"
                            badge_class = "severity-medium"
                        else:
                            severity_class = "low"
                            badge_class = "severity-low"
                        
                        st.markdown(f"""
                        <div class="risk-grid-item">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <span style="font-weight: bold; font-size: 1.1em;">Risk {i}</span>
                                <span class="severity-badge {badge_class}">Severity: {severity}/10</span>
                            </div>
                            <div style="font-weight: bold; margin-bottom: 5px; color: #333;">{risk.get('name', 'Unnamed Risk')}</div>
                            <div style="font-style: italic; color: #555; margin-bottom: 10px;">{risk.get('category', 'N/A')}</div>
                            <p style="margin-bottom: 10px;"><strong>{translations['description']}:</strong> {risk.get('description', 'No description')}</p>
                            <details>
                                <summary style="cursor: pointer; color: #4B7BFF;"><strong>{translations['why_it_matters']}</strong></summary>
                                <div style="background: #f5f5f5; padding: 10px; border-radius: 5px; margin-top: 5px;">
                                    {risk.get('why_it_matters', 'N/A')}
                                </div>
                            </details>
                            <details style="margin-top: 10px;">
                                <summary style="cursor: pointer; color: #4B7BFF;"><strong>{translations['mitigation']}</strong></summary>
                                <div style="background: #f5f5f5; padding: 10px; border-radius: 5px; margin-top: 5px;">
                                    {risk.get('mitigation', 'No mitigation strategy')}
                                </div>
                            </details>
                        </div>
                        """, unsafe_allow_html=True)
                    
                    st.markdown('</div>', unsafe_allow_html=True)
            
        except Exception as e:
            st.error(f"Failed to process PDF: {str(e)}")
            st.text(traceback.format_exc())

# AI Assistant Tab
with tab2:
    colored_header(
        label="üí¨ AI Legal Assistant",
        description="Chat with your document in natural language",
        color_name="violet-70"
    )
    
    if not st.session_state.extracted_text:
        st.info("Please upload and analyze a PDF document first.")
    else:
        # Language selection for speech input
        selected_lang_name = st.selectbox(
            "Select your speaking language:",
            options=list(LANGUAGE_CODES.keys()),
            index=0,
            key="lang_selector"
        )
        st.session_state.selected_speech_lang = LANGUAGE_CODES[selected_lang_name]
        
        # Display chat history
        for message in st.session_state.chat_history:
            if message["role"] == "user":
                with st.chat_message("user"):
                    st.markdown(f"**You:** {message['content']}")
                    if message.get("voice_input"):
                        st.caption(f"üé§ Voice input ({selected_lang_name}): {message['voice_input']}")
            else:
                with st.chat_message("assistant"):
                    st.markdown(message["content"])
        
        # Voice input section
        col1, col2 = st.columns([3, 1])
        with col1:
            if st.button("üé§ Record Voice Input", use_container_width=True, key="record_voice"):
                with st.spinner(f"Listening for {selected_lang_name}..."):
                    audio = record_audio(st.session_state.selected_speech_lang)
                    if audio:
                        transcribed_text = transcribe_audio(audio, st.session_state.selected_speech_lang)
                        if transcribed_text:
                            st.session_state.voice_input = transcribed_text
                            st.rerun()
        
        if st.session_state.voice_input:
            st.text_input("Voice input captured:", value=st.session_state.voice_input, disabled=True, key="voice_input_display")
        
        # Text input
        user_input = st.chat_input("Type your question about the document...", key="chat_input")
        
        if user_input or st.session_state.voice_input:
            final_input = st.session_state.voice_input if st.session_state.voice_input else user_input
            
            st.session_state.chat_history.append({
                "role": "user",
                "content": final_input,
                "voice_input": st.session_state.voice_input if st.session_state.voice_input else None
            })
            
            st.session_state.voice_input = ""
            
            with st.spinner("Analyzing your question..."):
                lang_code = list(LANGUAGE_CODES.keys()).index(st.session_state.document_language)
                lang_code = list(LANGUAGE_CODES.values())[lang_code][:2]  # Get 2-letter code
                response = chat_about_legal_document(
                    final_input,
                    st.session_state.legal_risks,
                    st.session_state.extracted_text,
                    lang_code
                )
                st.session_state.chat_history.append({"role": "assistant", "content": response})
            
            st.rerun()

# Instructions
with st.sidebar:
    colored_header(
        label="‚ÑπÔ∏è Instructions",
        description="How to use this tool",
        color_name="blue-70"
    )
    
    st.markdown("""
    ### Document Analysis
    1. **Upload** your PDF document
    2. **Select** the document language
    3. **Analyze** for legal risks
    4. **Review** the risk assessment
    
    ### AI Assistant
    1. First analyze a document
    2. **Select** your preferred language
    3. **Ask questions** via text or voice
    4. Get **document-specific answers**
    """)
    
    st.markdown("---")
    st.markdown("### üîç Sample Questions")
    st.markdown("""
    - What are the main contractual risks?
    - Explain the liability clauses
    - What's the most severe risk identified?
    - How can we mitigate compliance risks?
    """)

# Footer
st.markdown("---")
st.caption("¬© 2023 Multilingual Document Analyzer | AI-powered legal risk assessment")

# Add some space at the bottom
st.markdown("<br><br>", unsafe_allow_html=True)